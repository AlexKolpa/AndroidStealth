\section{Future Work}
\label{sec:future-work}

There are several aspects of the application than can be improved. Which
can be categorized under one of the following: usability, and morphing.
The categories will be discusses individually as they are separated both
technically and conceptually. 

\subsection{Usability}
In terms of usability there has been no formal study on what aspects of the application work work well. 
However, informal testing has shown several avenues of improvement. 

The testing has shown that the alternative launch methods could use closer attention when it comes to the usability.
The counterintuitive approaches to launching DroidStealth can be confusing.
There is also a risk that the methods, or the codes are forgotten when the user only sporadically opens the app;
This would render the data managed by the application lost forever.

With the providing of alternative access methods, easier access is provided to both the users and possible attackers.
The invisible widget that is provided is easily found in the widget list, though it is made more complex to detect when used in combination with a morphed DroidStealth.
The dialer launcher poses a risk when a user fills in the wrong launch code, as the entry won't be removed from the call log, and thus an attacked could be hinted towards the right pin. 
Also, if a user had made more mistakes, the attacker could merge the suspicious call log entries, and deduct the correct pin. 
A possible solution would be to check the call log for entries that are similar to the actual one, and to remove those as well.
Future work could address this issue with a solution that creates a more usable alternative launch method, while maintaining the security of the application.

Once the application has been launched, the user is required to pay close attention to the state of the application, and the state of the files managed by it.
A small human error can result in inadvertent data breaches, especially when the data in the application is opened in other apps.

Monitoring the application's lifecycle more closely could resolve some of these issues:
For example, `listening' to home button presses could be used to trigger the locking of files automatically whenever the app gets out of focus.
Another solution that has been discussed is limiting the time during which a file may be unlocked, which could restore the encryption after a (user-)designated duration.

\subsection{Morphing} 
\label{sec:limitations:morphing}

The basic features of the morphing library have been implemented, however it is not without limitations.
Two areas of improvement have been identified; app renaming restrictions and the lack of integrity verification.

Names used for morphing have to be the same length or shorter than the name originally given to the application.
Preliminary research indicates that this limitation can be overcome but not all size indicators in encoded Android manifests have not identified.
Alternatively increased support for self-compilation could remove this limitation.

The other component of naming is the `package name' staying consistent across morphs. 
The package name of an application is a naming convention which Android uses as an identifier for applications in its app store.
For casual searches, the package name is not relevant in most situations.
However there is one exception, namely if DroidStealth would be on an app store. 
As apps are identified there by package name this would make it easy to reveal its presence just by searching for it on the appstore.
Currently the only solution is to not be available through any app store.
\todo{move this paragraph to vulnerability analysis?}

Integrity validation is not included in morphing.
With integrity validation we mean that the actual code itself is not modified to change the behaviour of DroidStealth, for example introducing a backdoor.
Normally this is something that the Android package system takes care of, but morphing has unique demands that makes it impossible to rely on built-in measures.
These measures rely on using a private key for signing the code, however to allow updating for the application after morphing the private key has to be bundled with the software so it can be signed again.
With access to this key anyone can create a modified version of the morphed application and spread that as an `update'.
Solving this problem is non-trivial and requires more research.

\subsection{Reinstalling the application}
When the application is reinstalled from, for example, a morphed android application package, the encryption key used to lock data is replaced.
This means that the data locked before the reinstallation is impossible to decrypt; a significant limitation in the usability.

A method of deriving a key that is consistent through reinstalling the application is required, while it remains underivable for external parties.

Reinstalling the application from the newly created application package unfortunately replaces the encryption key that is used to encrypt and decrypt the files.
This means that the data stored before the reinstall cannot be unlocked anymore; a harsh limitation in the usga
